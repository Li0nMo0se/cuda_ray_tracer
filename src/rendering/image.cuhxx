#include "rendering/image.cuh"
namespace rendering
{
/** Image **/
template <typename T>
Image<T>::Image(const int32_t width, const int32_t height)
    : width_(width)
    , height_(height)
{
}

template <typename T>
Image<T>::~Image()
{
}

template <typename T>
inline const T* Image<T>::data_get() const
{
    return this->data_;
}

template <typename T>
inline T* Image<T>::data_get()
{
    return this->data_;
}

template <typename T>
inline int32_t Image<T>::width_get() const
{
    return this->width_;
}

template <typename T>
inline int32_t Image<T>::height_get() const
{
    return this->height_;
}

template <typename T>
void Image<T>::_copy(Image<T>& dst, cudaMemcpyKind memcpy_kind) const
{
    cuda_safe_call(cudaMemcpy(dst.data_,
                              this->data_,
                              sizeof(T) * this->width_ * this->height_,
                              memcpy_kind));
}

/** DeviceImage **/
template <typename T>
DeviceImage<T>::DeviceImage(const int32_t width, const int32_t height)
    : Image<T>(width, height)
{
    // FIXME: cudaMallocPitch
    cudaMalloc((void**)&this->data_, sizeof(T) * this->width_ * this->height_);
}

template <typename T>
void DeviceImage<T>::copy(HostImage<T>& copy_host) const
{
    this->_copy(copy_host, cudaMemcpyDeviceToHost);
}

template <typename T>
void DeviceImage<T>::free()
{
    cuda_safe_call(cudaFree(this->data_));
}

template <typename T>
void DeviceImage<T>::save(const std::string& filename) const
{
    // Create HostImage from DeviceImage
    HostImage<T> copy_host(this->width_, this->height_);
    this->copy(copy_host);
    // Save it
    copy_host.save(filename);
    // Release memory
    copy_host.free();
}

/** Host Image **/
template <typename T>
HostImage<T>::HostImage(const int32_t width, const int32_t height)
    : Image<T>(width, height)
{
    this->data_ =
        static_cast<T*>(std::malloc(sizeof(T) * this->width_ * this->height_));
}

template <typename T>
void HostImage<T>::free()
{
    std::free(this->data_);
}

template <typename T>
void HostImage<T>::save(const std::string& filename) const
{
    // TODO
}

template <typename T>
void HostImage<T>::copy(DeviceImage<T>& copy_device) const
{
    this->_copy(copy_device, cudaMemcpyHostToDevice);
}

/** ImageHandler **/
template <typename T>
ImageHandler<T>::ImageHandler(const int32_t width, const int32_t height)
    : host(width, height)
    , device(width, height)
{
}

template <typename T>
ImageHandler<T>::~ImageHandler()
{
    host.free();
    device.free();
}

template <typename T>
void ImageHandler<T>::save(const std::string& filename) const
{
    device.save(filename);
}

template <typename T>
void ImageHandler<T>::copy_host_to_device()
{
    host.copy(device);
}

template <typename T>
void ImageHandler<T>::copy_device_to_host()
{
    device.copy(host);
}

} // namespace rendering