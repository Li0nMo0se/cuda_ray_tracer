#include "rendering/image.cuh"
#include <fstream>
#include <ostream>

namespace rendering
{
/** Image **/
template <typename T>
Image<T>::Image(const int32_t width, const int32_t height)
    : width_(width)
    , height_(height)
{
}

template <typename T>
Image<T>::~Image()
{
}

template <typename T>
inline const T* Image<T>::data_get() const
{
    return this->data_;
}

template <typename T>
inline T* Image<T>::data_get()
{
    return this->data_;
}

template <typename T>
inline int32_t Image<T>::width_get() const
{
    return this->width_;
}

template <typename T>
inline int32_t Image<T>::height_get() const
{
    return this->height_;
}

template <typename T>
void Image<T>::_copy(Image<T>& dst, cudaMemcpyKind memcpy_kind) const
{
    cuda_safe_call(cudaMemcpy(dst.data_,
                              this->data_,
                              sizeof(T) * this->width_ * this->height_,
                              memcpy_kind));
}

/** DeviceImage **/
template <typename T>
DeviceImage<T>::DeviceImage(const int32_t width, const int32_t height)
    : Image<T>(width, height)
{
    // FIXME: cudaMallocPitch
    cudaMalloc((void**)&this->data_, sizeof(T) * this->width_ * this->height_);
}

template <typename T>
void DeviceImage<T>::copy(HostImage<T>& copy_host) const
{
    this->_copy(copy_host, cudaMemcpyDeviceToHost);
}

template <typename T>
void DeviceImage<T>::free()
{
    cuda_safe_call(cudaFree(this->data_));
}

template <typename T>
void DeviceImage<T>::save(const std::string& filename) const
{
    // Create HostImage from DeviceImage
    HostImage<T> copy_host(this->width_, this->height_);
    this->copy(copy_host);
    // Save it
    copy_host.save(filename);
    // Release memory
    copy_host.free();
}

/** Host Image **/
template <typename T>
HostImage<T>::HostImage(const int32_t width, const int32_t height)
    : Image<T>(width, height)
{
    this->data_ =
        static_cast<T*>(std::malloc(sizeof(T) * this->width_ * this->height_));
}

template <typename T>
void HostImage<T>::free()
{
    std::free(this->data_);
}

template <typename T>
static uint8_t get_color_with_boundary(const T val)
{
    if (val < static_cast<T>(0))
        return 0;
    if (val > static_cast<T>(255))
        return 255;
    return static_cast<uint8_t>(val);
}

template <>
void inline HostImage<color::Color3>::save(const std::string& filename) const
{
    std::ofstream of(filename, std::ios_base::out | std::ios_base::binary);

    if (of.fail())
    {
        std::cerr << "Cannot save the image in the file " << filename
                  << std::endl;
        return;
    }

    of << "P6" << std::endl;
    of << width_ << " " << height_ << std::endl;
    uint32_t max_value = std::numeric_limits<uint8_t>::max();
    of << max_value << std::endl;

    for (int32_t y = 0; y < height_; y++)
    {
        for (int32_t x = 0; x < width_; x++)
        {
            const color::Color3& curr_pixel = data_[y * width_ + x];
            uint8_t r = get_color_with_boundary<float>(curr_pixel[0]);
            uint8_t g = get_color_with_boundary<float>(curr_pixel[1]);
            uint8_t b = get_color_with_boundary<float>(curr_pixel[2]);

            of << r << g << b;
        }
    }

    of.close();
}

template <typename T>
void inline HostImage<T>::save(const std::string& filename) const
{
    assert(false);
}

template <typename T>
void HostImage<T>::copy(DeviceImage<T>& copy_device) const
{
    this->_copy(copy_device, cudaMemcpyHostToDevice);
}

/** ImageHandler **/
template <typename T>
ImageHandler<T>::ImageHandler(const int32_t width, const int32_t height)
    : host(width, height)
    , device(width, height)
{
}

template <typename T>
ImageHandler<T>::~ImageHandler()
{
    host.free();
    device.free();
}

template <typename T>
void ImageHandler<T>::save(const std::string& filename) const
{
    device.save(filename);
}

template <typename T>
void ImageHandler<T>::copy_host_to_device()
{
    host.copy(device);
}

template <typename T>
void ImageHandler<T>::copy_device_to_host()
{
    device.copy(host);
}

} // namespace rendering